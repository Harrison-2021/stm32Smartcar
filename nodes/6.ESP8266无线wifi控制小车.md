#  一、ESP8266介绍

**ESP8266EX 由乐鑫公司开发，提供了⼀套⾼度集成的 <font color="#fd6f01">Wi-Fi SoC</font> 解决⽅案**，其低功耗、紧凑设计和⾼稳定性可以满⾜⽤户的需求。 

ESP8266EX 拥有完整的且**⾃成体系的 Wi-Fi ⽹络功能**，既能够独⽴应⽤，也**可以作为从机搭载于其他主机 MCU 运⾏**。

**当 ESP8266EX 独⽴应⽤时，能够直接从外接ﬂash 中启动**。内置的⾼速缓冲存储器有利于提⾼系统性能，并且优化存储系统。

此外 ESP8266EX 只需**通过 SPI/SDIO 接⼝或 UART 接⼝即可作为 Wi-Fi 适配器**，应⽤到基于任何微控制器的设计中。

ESP8266EX 集成了天线开关、射频 balun、功率放⼤器、低噪声放⼤器、滤波器和电源管理模块。这样紧凑的设计仅需极少的外部电路并且能将 PCB 的尺⼨降到最⼩。

ESP8266EX 还集成了增强版的 Tensilica’s L106 钻⽯系列 32-bit 内核处理器，带⽚上 SRAM。**ESP8266EX 可以通过 IO 外接传感器和其他设备**。

![图片描述](https://img.mukewang.com/wiki/6405b8fb09e584c712800603.jpg)

**技术文档参考链接:**https://www.espressif.com.cn/zh-hans/support/documents/technical-documents?keys=&field_type_tid_parent=esp8266Series-SoCs&field_type_tid[]=14



# 二、硬件原理图阅读

1.wifi模块通过wife接受到数据，会通过TX发出去，发给MCU_UART5_RX(UART2_RX),触发UART2_RX接收中断，在中断中自定义代码逻辑

2.UART1与UART2通信，两个UART模块都与单片机相连，UART1接收到数据后，将数据通过UART2_TX转发（<font color="#fd6f01">**数据是uart_buf,注意不是UART1发，UART2收，而是UART2_TX，只不过发的数据是UART1_RX收到的uart1_buf数据**）</font>，<font color=green>**然后，wifi模块的RX接收，wifi模块处理后，通过TX发送相应信息，转发给UART2_RX**</font>，定义接收中断，可在中断中将数据通过UART1发送，单片机或串口工具监听到电平，进行显示。

3.<font color="#fd6f01">**因此触发UART2_RX中断，只能是wifi模块发送信息，蓝牙模块类似，蓝牙模块通过蓝牙接收到信息后，会通过蓝牙的TX发送到UART2_RX，触发中断，反之，通过UART1接收的数据，只能通过UART2_TX发送，不能触发UART2_RX接收中断事件**</font>。

![图片描述](https://img.mukewang.com/wiki/6405b90f093bccb209141280.jpg)



# 三、STM32CubeMx配置

![图片描述](https://img.mukewang.com/wiki/6405b92a09af5a4912800659.jpg)



# 四、PC机与ESP8266建立通信



## 1.UART1与UART2桥接原理

![图片描述](https://img.mukewang.com/wiki/6405b93b08ed2bac07210421.jpg)



## 2.代码实现

```c
uint8_t uart1_rx_buffer[1024];
uint8_t uart2_rx_buffer[1024];

void uart_interrupt_init(void)
{
        //HAL_UART_Receive_IT(&huart1,uart1_rx_buffer,sizeof(uart1_rx_buffer));
        HAL_UARTEx_ReceiveToIdle_IT(&huart1,uart1_rx_buffer,sizeof(uart1_rx_buffer));
        HAL_UARTEx_ReceiveToIdle_IT(&huart2,uart2_rx_buffer,sizeof(uart2_rx_buffer));
}

void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
  int i;
        
        if(huart == &huart1){
            //recv data to uart2
            HAL_UART_Transmit(&huart2,uart1_rx_buffer,Size,HAL_MAX_DELAY);
            HAL_UARTEx_ReceiveToIdle_IT(&huart1,uart1_rx_buffer,sizeof(uart1_rx_buffer));
         }else if(huart == &huart2){
            HAL_UART_Transmit(&huart1,uart2_rx_buffer,Size,HAL_MAX_DELAY);
            HAL_UARTEx_ReceiveToIdle_IT(&huart2,uart2_rx_buffer,sizeof(uart2_rx_buffer));
         }
        
         return;
}
```

### 测试结果



# 五、ESP8266配置wifi的AT指令



## 1、AT指令介绍

AT指令是应用于终端设备与PC应用之间的连接与通信的指令。AT 即Attention(注意、留心)。通用 AT 命令有四种类型：

![图片描述](https://img.mukewang.com/wiki/6405b952099c0eb509920255.jpg)

> **注意**:**每条AT指令都以\r\n结尾**

**详细介绍参考这里:**https://docs.espressif.com/projects/esp-at/zh_CN/release-v2.2.0.0_esp8266/AT_Command_Set/index.html

**wifi指令集参考这里:**https://docs.espressif.com/projects/esp-at/zh_CN/release-v2.2.0.0_esp8266/AT_Command_Set/Wi-Fi_AT_Commands.html#cmd-jap



## 2、Station（客户端模式）



### (1)设置模式

```assembly
AT+CWMODE= <mode>[,<auto_connect>]

<mode>：模式
0: 无 Wi-Fi 模式，并且关闭 Wi-Fi RF
1: Station 模式
2: SoftAP 模式
3: SoftAP+Station 模式

<auto_connect>：切换ESP设备的Wi-Fi模式时（例如，从SoftAP或无Wi-Fi模式切换为Station模式
或 SoftAP+Station 模式），是否启用自动连接 AP 的功能，默认值：1。参数缺省时，使用默认值，
也就是能自动连接。

0: 禁用自动连接 AP 的功能
1: 启用自动连接 AP 的功能，若之前已经将自动连接 AP 的配置保存到 flash 中，则 ESP 设备将自动连接AP
```

![图片描述](https://img.mukewang.com/wiki/6405b9690908397509450713.jpg)



### (2)查询工作模式

```assembly
命令：
AT+CWMODE?

响应：
+CWMODE:<mode>
OK 
```

![图片描述](https://img.mukewang.com/wiki/6405b97a0933ac3009490718.jpg)



### (3)**扫描当前可用的 AP**

```assembly
命令:
AT+CWLAP=[<ssid>,<mac>,<channel>,<scan_type>,<scan_time_min>,<scan_time_max>]
<ssid>         ：字符串参数，AP的SSID(wifi名称)
<rssi>         ：信号强度
<mac>          ：字符串参数，AP的MAC地址
<channel>      ：信道号
<scan_type>    ：Wi-Fi 扫描类型 0: 主动扫 描1: 被动扫描
<scan_time_min>：每个信道最短扫描时间，单位：毫秒，范围：[0,1500]
                 如果扫描类型为被动扫描，本参数无效
<scan_time_max>：每个信道最长扫描时间，单位：毫秒，范围：[0,1500]，
                 如果设为 0，固件采用参数默认值，主动扫描为 120 ms，被动扫描为 360 ms
                 
                 
响应：
+CWLAP:<ecn>,<ssid>,<rssi>,<mac>,<channel>,<freq_offset>,
       <freqcal_val>,<pairwise_cipher>,<group_cipher>,<bgn>,<wps>
OK

<ecn>：加密方式
    0: OPEN
    1: WEP
    2: WPA_PSK
    3: WPA2_PSK
    4: WPA_WPA2_PSK
    5: WPA2_ENTERPRISE
    6: WPA3_PSK
    7: WPA2_WPA3_PSK
    
<rssi>           ：信号强度
<freq_offset>    ：频偏（保留项目）
<freqcal_val>    ：频率校准值（保留项目）
<pairwise_cipher>：成对加密类型
0: None
1: WEP40
2: WEP104
3: TKIP
4: CCMP
5: TKIP and CCMP
6: AES-CMAC-128
7: 未知

<group_cipher>   ：组加密类型，与 <pairwise_cipher> 参数的枚举值相同
<bgn>            ：802.11 b/g/n，若 bit 设为 1，则表示使能对应模式，若设为 0，则表示禁用对应模式
bit 0: 是否使能 802.11b 模式
bit 1: 是否使能 802.11g 模式
bit 2: 是否使能 802.11n 模式

<wps>            ：wps flag
0: 不支持 WPS
1: 支持 WPS

示例:
AT+CWLAP
AT+CWLAP="Wi-Fi"// 寻找指定 SSID 的 AP
AT+CWLAP="Wi-Fi","ca:d7:19:d8:a6:44",6,0,400,1000

```

![图片描述](https://img.mukewang.com/wiki/6405b98c093ba2ed09470713.jpg)



### (4)**连接AP**

```assembly
命令:
AT+CWJAP=[<ssid>],[<pwd>][,<bssid>][,<pci_en>][,<reconn_interval>]
         [,<listen_interval>][,<scan_mode>][,<jap_timeout>][,<pmf>]
         
<ssid>           ：目标 AP 的 SSID 如果 SSID 和密码中有 ,、"、\\ 等特殊字符，需转义
<pwd>            ：密码最长 64 字节 ASCII
<bssid>          ：目标 AP 的 MAC 地址，当多个 AP 有相同的 SSID 时，该参数不可省略
<channel>        ：信道号
<rssi>           ：信号强度
<pci_en>         ：PCI 认证
0: ESP station 可与任何一种加密方式的 AP 连接，包括 OPEN 和 WEP
1: ESP station 可与除 OPEN 和 WEP 之外的任何一种加密方式的 AP 连接
<reconn_interval>：Wi-Fi 重连间隔，单位：秒
                   默认值：1，最大值：7200
                   0: 断开连接后，ESP station 不重连 AP
                   [1,7200]: 断开连接后，ESP station 每隔指定的时间与 AP 重连
<listen_interval>：监听 AP beacon 的间隔，单位为 AP beacon 间隔，默认值：3，范围：[1,100]
<scan_mode>      ：扫描模式
0: 快速扫描，找到目标 AP 后终止扫描，ESP station 与第一个扫描到的 AP 连接
1: 全信道扫描，所有信道都扫描后才终止扫描，ESP station 与扫描到的信号最强的 AP 连接

<jap_timeout>    ：AT+CWJAP 命令超时的最大值，单位：秒，默认值：15，范围：[3,600]
<pmf>            ：PMF（Protected Management Frames，受保护的管理帧），默认值 0


响应:
WIFI CONNECTEDWIFI 
GOT IP

OK
[WIFI GOT IPv6 LL]
[WIFI GOT IPv6 GL]

或
+CWJAP:<error code>
ERROR

<error code>     ：错误码，仅供参考
1: 连接超时
2: 密码错误
3: 无法找到目标 AP
4: 连接失败
其它值: 发生未知错误
```

![图片描述](https://img.mukewang.com/wiki/6405b9a0090f723e09450717.jpg)

<font color="#fd6f01">**ESP8266不能连接5GHZ频段的wifi**</font>

ESP8266在连接wifi的时候，如果wifi是5GHZ频段，会连接失败。WiFi设备工作在 2.4G 频段或 5G 频段，但ESP8266 和 ESP32 目前只支持 2.4G 频段,也就是说：**8266只能接收2.4Ghz**的信号。

![图片描述](https://img.mukewang.com/wiki/6405b9c109be851809490715.jpg)

![图片描述](https://img.mukewang.com/wiki/6405b9d109c242b910802340.jpg)



### (5)查询当前连接的AP

```plain
命令:
AT+CWJAP?

响应：
+CWJAP:<ssid>,<bssid>,<channel>,<rssi>,<pci_en>,
       <reconn_interval>,<listen_interval>,<scan_mode>,<pmf>
OK

<ssid>           ：目标 AP 的 SSID 如果 SSID 和密码中有 ,、"、\\ 等特殊字符，需转义
<pwd>            ：密码最长 64 字节 ASCII
<bssid>          ：目标 AP 的 MAC 地址，当多个 AP 有相同的 SSID 时，该参数不可省略
<channel>        ：信道号
<rssi>           ：信号强度
<pci_en>         ：PCI 认证
0: ESP station 可与任何一种加密方式的 AP 连接，包括 OPEN 和 WEP
1: ESP station 可与除 OPEN 和 WEP 之外的任何一种加密方式的 AP 连接
<reconn_interval>：Wi-Fi 重连间隔，单位：秒
                   默认值：1，最大值：7200
                   0: 断开连接后，ESP station 不重连 AP
                   [1,7200]: 断开连接后，ESP station 每隔指定的时间与 AP 重连
<listen_interval>：监听 AP beacon 的间隔，单位为 AP beacon 间隔，默认值：3，范围：[1,100]
<scan_mode>      ：扫描模式
0: 快速扫描，找到目标 AP 后终止扫描，ESP station 与第一个扫描到的 AP 连接
1: 全信道扫描，所有信道都扫描后才终止扫描，ESP station 与扫描到的信号最强的 AP 连接

<jap_timeout>    ：AT+CWJAP 命令超时的最大值，单位：秒，默认值：15，范围：[3,600]
<pmf>            ：PMF（Protected Management Frames，受保护的管理帧），默认值 0
```

![图片描述](https://img.mukewang.com/wiki/6405b9e909fd8b9909450719.jpg)



### (6)查询**Station 的 IP 地址**

```plain
命令：
AT+CIPSTA?

响应:
+CIPSTA:ip:<"ip">
+CIPSTA:gateway:<"gateway">
+CIPSTA:netmask:<"netmask">
+CIPSTA:ip6ll:<"ipv6 addr">
+CIPSTA:ip6gl:<"ipv6 addr">

OK
```

![图片描述](https://img.mukewang.com/wiki/6405ba0409d3039109500716.jpg)



### (7)设定静态IP

```plain
命令:
AT+CIPSTA=<"ip">[,<"gateway">,<"netmask">]

响应：
OK
```

![图片描述](https://img.mukewang.com/wiki/6405ba150989f80109470717.jpg)



## 3、AP（服务端模式）



### (1)设置模式

```plain
AT+CWMODE=2
```



### (2)**配置 ESP SoftAP 参数**

```plain
命令：
AT+CWSAP=<ssid>,<pwd>,<chl>,<ecn>[,<max conn>][,<ssid hidden>]

<ssid>         ：字符串参数，接入点名称
<pwd>          ：字符串参数，密码，范围：8 ~ 64 字节 ASCII
<channel>      ：信道号
<ecn>          ：加密方式，不支持 WEP
0: OPEN(不需要密码)
2: WPA_PSK
3: WPA2_PSK
4: WPA_WPA2_PSK
[<max conn>]   ：允许连入 ESP SoftAP 的最多 station 数目，取值范围：[1,10]
[<ssid hidden>]：
0: 广播 SSID（默认）
1: 不广播 SSID

响应：
OK

案例:
AT+CWSAP="ESP8266","0123456789",11,4
```

![图片描述](https://img.mukewang.com/wiki/6405ba3309bd7d3409480719.jpg)



### (3)查询 ESP SoftAP 的配置参数

```plain
命令:
AT+CWSAP?

响应：
+CWSAP:<ssid>,<pwd>,<channel>,<ecn>,<max conn>,<ssid hidden>
OK

<ssid>         ：字符串参数，接入点名称
<pwd>          ：字符串参数，密码，范围：8 ~ 64 字节 ASCII
<channel>      ：信道号
<ecn>          ：加密方式，不支持 WEP
0: OPEN(不需要密码)
2: WPA_PSK
3: WPA2_PSK
4: WPA_WPA2_PSK
[<max conn>]   ：允许连入 ESP SoftAP 的最多 station 数目，取值范围：[1,10]
[<ssid hidden>]：
0: 广播 SSID（默认）
1: 不广播 SSID
```

![图片描述](https://img.mukewang.com/wiki/6405ba47096d45eb09470717.jpg)



### (4)开启多连接模式

```plain
AT+CIPMUX=1

开启多连接模式，因为只有在开启多连接模式的时候才能开启服务器模式。
注意：透传只能在单连接模式下进行。
```



## 4、Station+AP（混合模式）



### (1)设置模式

```plain
AT+CWMODE=3
```



### (2)**配置 ESP SoftAP 参数**

```plain
AT+CWSAP="ESP8266","0123456789",11,4

```



### (3)**连接AP**

```plain
AT+CWJAP="TP-LINK_40C4",""
```



## 5、TCP协议传输数据



### (1)**建立与断开TCP 连接**

```plain
命令:
//单连接 (AT+CIPMUX=0):
AT+CIPSTART=<"type">,<"remote host">,<remote port>[,<keep alive>][,<"local IP">]

//多连接 (AT+CIPMUX=1):
AT+CIPSTART=<link ID>,<"type">,<"remote host">,<remote port>[,<keep alive>][,<"local IP">]

<link ID>      ：网络连接 ID (0 ~ 4)，用于多连接的情况
<"type">       ：字符串参数，表示网络连接类型，”TCP” 或 “TCPv6”。默认值：”TCP”
<"remote host">：字符串参数，表示远端 IPv4 地址、IPv6 地址，或域名
<remote port>  ：远端端口值
<keep alive>   ：TCP keep-alive 间隔，默认值：0
0: 禁用 TCP keep-alive 功能
1 ~ 7200: 检测间隔，单位：秒
<”local IP”>   ：连接绑定的本机 IPv4 地址或 IPv6 地址，该参数在本地多网络接口时和本地多 IP 地址时
                 非常有用。默认为禁用，如果您想使用，需自行设置，空值也为有效值
                 
响应：
CONNECT
OK

案例:
AT+CIPSTART="TCP","192.168.11.102",8080
断开链接
AT+CIPCLOSE

```



### (2)发送数据

```plain
命令:
// 单连接：(AT+CIPMUX=0)
AT+CIPSEND=<length>

// 多连接：(AT+CIPMUX=1)
AT+CIPSEND=<link ID>,<length>

响应：
OK
>

注意:
上述响应表示 AT 已准备好接收串行数据，此时您可以输入数据，当 AT 接收到的数据长度达到 <length> 后，
数据传输开始。

如果未建立连接或数据传输时连接被断开，返回：ERROR
如果数据传输成功，返回：SEND OK

案例:
AT+CIPSEND=5

```



### (3)建立TCP服务器

```plain
命令:
AT+CIPSERVER=<mode>[,<param2>][,<"type">][,<CA enable>]

<mode>     ：0: 关闭服务器 , 1: 建立服务器
<param2>   ：port:端口号，缺省值为333
<"type">   ：服务器类型："TCP"，"TCPv6"，"SSL"，或 "SSLv6". 默认值："TCP"。
             由于内存限制，此参数不适用于 ESP8266 设备
<CA enable>：由于内存限制，此参数不适用于 ESP8266 设备
             0：不使用 CA 认证
             1：使用 CA 认证
             
             
注意:
多连接情况下 (AT+CIPMUX=1)，才能开启服务器,创建服务器后，自动建立服务器监听，最多只允许创建一个服务器
当有客户端接入，会自动占用一个连接 ID

响应:
OK

示例:
// 建立 TCP 服务器
AT+CIPMUX=1
AT+CIPSERVER=1,8888

```



### (4)查询IP

```plain
命令：
AT+CIFSR

响应:
AT+CIFSR
+CIFSR:APIP,"192.168.4.1"
+CIFSR:APMAC,"f6:cf:a2:5e:31:d1"

+CIFSR:STAIP,"192.168.11.103"
+CIFSR:STAMAC,"f4:cf:a2:5e:31:d1"

OK

```



## 6、UDP协议传输数据



### (1)**建立 UDP 传输**

```plain
命令：
//单连接：(AT+CIPMUX=0)
AT+CIPSTART=<"type">,<"remote host">,<remote port>[,<local port>,<mode>,<"local IP">]

//多连接：(AT+CIPMUX=1)
AT+CIPSTART=<link ID>,<"type">,<"remote host">,
            <remote port>[,<local port>,<mode>,<"local IP">]
            
<link ID>      ：网络连接 ID (0 ~ 4)，用于多连接的情况
<"type">       ：字符串参数，表示网络连接类型，”UDP” 或 “UDPv6”。默认值：”TCP”
<"remote host">：字符串参数，表示远端 IPv4 地址、IPv6 地址，或域名
<remote port>  ：远端端口值
<local port>   ：ESP 设备的 UDP 端口值
<mode>         ：在 UDP Wi-Fi 透传下，本参数的值必须设为 0

0: 接收到 UDP 数据后，不改变对端 UDP 地址信息（默认）
1: 仅第一次接收到与初始设置不同的对端 UDP 数据时，改变对端 UDP 地址信息为发送数据设备的 IP 地址和端口
2: 每次接收到 UDP 数据时，都改变对端 UDP 地址信息为发送数据的设备的 IP 地址和端口

<”local IP”>   ：连接绑定的本机 IPv4 地址或 IPv6 地址，该参数在本地多网络接口时和本地多 
                 IP 地址时非常有用。默认为禁用，如果您想使用，需自行设置，空值也为有效值
                 
                 
示例:
AT+CIPSTART="UDP","192.168.101.110",1000,1002,2
AT+CIPSTART="UDP","192.168.101.110",1000,,,"192.168.101.100"

```



### (2)发送数据

```plain
// UDP 传输可指定对端主机和端口
AT+CIPSEND=[<link ID>,]<length>[,<"remote host">,<remote port>]

<link ID>      ：网络连接 ID (0 ~ 4)，用于多连接的情况
<length>       ：数据长度，最大值：2048 字节
<”remote host”>：UDP 传输可以指定对端主机：IPv4 地址、IPv6 地址，或域名
<remote port>  ：UDP 传输可以指定对端端口

```



## 7、透传模式



### (1)普通模式与透传模式

在普通传输模式下，用户可以发送 AT 命令。 例如，用户可以通过 AT+CIPSEND 命令，发送 AT 命令口收到的 MCU 数据到传输对端。从传输对端收到的数据，会通过 AT 命令口返回给 MCU，同时会附带 +IPD 信息。普通传输模式时，如果连接断开，ESP 不会重连，并提示连接断开。

**透传模式也称为 “透传发送接收模式”**。在透传模式下，用户不能发送其它 AT 命令，除了特别的 +++ 命令。AT 命令口收到的所有的 MCU 数据都将无修改地，发送到传输对端。从传输对端收到的数据也会通过 AT 命令口无修改地，返回给 MCU。**Wi-Fi 透传模式传输时，如果连接断开，ESP 会不停地尝试重连，此时单独输入** **+++** **退出透传，则停止重连。**

![图片描述](https://img.mukewang.com/wiki/6405ba97095faebe10970186.jpg)



### (2)设置透传模式

```plain
命令:
AT+CIPMODE=<mode>

<mode>:
0: 普通传输模式
1: Wi-Fi 透传接收模式，仅支持 TCP 单连接、UDP 固定通信对端

响应:
OK

注意:
   配置更改不保存到 flash
代码块123456789101112
```



### (3)进入 Wi-Fi 透传模式

```plain
命令:
AT+CIPSEND

响应：
OK
>
或
ERROR

注意1:
进入 Wi-Fi 透传模式，ESP8266 设备每次最大接收 2048 字节，最大发送 1460 字节
如果当前接收的数据长度大于最大发送字节数，AT 将立即发送；否则，接收的数据将在 20 ms 内发送。
当输入单独一包 +++ 时，退出 透传模式 下的数据发送模式，请至少间隔 1 秒再发下一条 AT 命令。

注意2:
本命令必须在开启 透传模式 以及单连接下使用。
若为 Wi-Fi UDP 透传，AT+CIPSTART 命令的参数 <mode> 必须设置为 0。
代码块1234567891011121314151617
```



### (4)**设置开机进入 TCP\**\*\*透传模式\*\**\*信息**

```plain
命令:
AT+SAVETRANSLINK=<mode>,<"remote host">,<remote port>[,<"type">,<keep alive>]

<mode>          :
0: 关闭 ESP 上电进入 Wi-Fi 透传模式
1: 开启 ESP 上电进入 Wi-Fi 透传模式(需要重启生效，下次上电自动进入 透传模式)

<”remote host”> ：字符串参数，表示远端 IPv4 地址、IPv6 地址，或域名
<remote port>   ：远端端口值

<”type”>        ：字符串参数，表示传输类型：”TCP”，”TCPv6”，”SSL”，或 “SSLv6”。默认值：”TCP”

<keep alive>    ：TCP keep-alive 间隔，默认值：0
0: 禁用 keep-alive 功能
1 ~ 7200: 检测间隔，单位：秒

示例:
AT+SAVETRANSLINK=1,"192.168.11.104",8080,"TCP"
AT+SAVETRANSLINK=0 关闭透传
代码块12345678910111213141516171819
```



### (5)**设置开机进入 UDP** **透传模式\**\**信息**

```plain
命令:
AT+SAVETRANSLINK=<mode>,<"remote host">,<remote port>,[<"type">,<local port>]

<mode>:
0: 关闭 ESP 上电进入 Wi-Fi 透传模式
1: 开启 ESP 上电进入 Wi-Fi 透传模式
<"remote host">：字符串参数，表示远端 IPv4 地址、IPv6 地址，或域名
<remote port>  ：远端端口值
<”type”>       ：字符串参数，表示传输类型：”UDP” 或 “UDPv6”。默认值：”TCP”
[<local port>] ：开机进入 UDP 传输时，使用的本地端口

示例:
AT+SAVETRANSLINK=1,"192.168.11.104",8080,"UDP"
AT+SAVETRANSLINK=0 关闭透传
代码块1234567891011121314
```



# 六、通过ESP8266控制小车

核心编程思想:

**将ESP8266设置为AP模式，并让它运行在TCP Server状态**，**这样其他APP就可以连接ESP8266的wifi热点，并通过TCP Client进行通信**。**这里通过发送"W/S/A/D"四个字符来控制小车。**



## 1.AT指令发送和接收函数封装



### (1)发送函数

```c
void esp8266_send_cmd(const char *cmd)
{
         int ret;

        printf("Send AT CMD:%s\r\n",cmd);
        
        ret = HAL_UART_Transmit(&huart2,(uint8_t *)cmd,strlen(cmd),1000);
        if(ret != HAL_OK){
                printf("Fail to send AT cmd:%s\r\n",cmd);
                return;
        }
        
        return;
}
代码块1234567891011121314
```



### (2)接收函数

```c
int esp8266_recv_ack(void)
{
        int count = 0;
        uint8_t rx_buffer[300];
        uint8_t ack_buffer[1024] = {0};
        
        
        while(count < 3){
                memset(rx_buffer,0,sizeof(rx_buffer));
                HAL_UART_Receive(&huart2,rx_buffer,sizeof(rx_buffer),1000);
                if(strstr((const char *)rx_buffer,"OK")){
                          printf("Recv AT ACK:%s\r\n",rx_buffer);
                          return 0;
                }
                strcat((char *)ack_buffer,(const char *)rx_buffer);
                count ++;
        }
        
        printf("Recv AT ACK:%s\r\n",ack_buffer);
        if(strstr((const char *)ack_buffer,"OK")){
                return 0;
        }
        
        return -1;
}
```



## 2.重置ESP8266



### (1)相关AT指令

```plain
+++           退出透传模式
AT+RST\r\n    复位ESP8266
AT\r\n        测试ESP8266 AT指令通信是否正常
代码块123
```



### (2)代码实现

```c
int esp8266_reset(void)
{
        int ret;
        
        //send "+++" quit passthrough mode
        esp8266_send_cmd("+++");
        HAL_Delay(1000);
        
        //send "AT+RST\r\n" reset esp8266
        esp8266_send_cmd("AT+RST\r\n");
        HAL_Delay(3000);
        
        //send "AT\r\n" test
        esp8266_send_cmd("AT\r\n");
        
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 is not alive\r\n");
                 return -1;
        }
        
        printf("Reset ESP8266 Success\r\n");
        
        return 0;
}
```



## 3.配置ESP8266进入AP模式



### (1)相关AT指令

```plain
AT+CWMODE=2\r\n  进入AP模式
AT+CWSAP=\"ESP8266-WIFI\",\"0123456789\",11,4\r\n 配置热点
```



### (2)相关代码实现

```c
int esp8266_enter_ap_mode(void)
{
        int ret;
        
        //send "AT+CWMODE=2\r\n" to ap mode
        esp8266_send_cmd("AT+CWMODE=2\r\n");
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 enter ap mode failed\r\n");
                 return -1;
        }
        
        //config ap ssid and pwd
        esp8266_send_cmd("AT+CWSAP=\"ESP8266-WIFI\",\"0123456789\",11,4\r\n");
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 config ap ssid and pwd failed\r\n");
                 return -1;
        }
        
        printf("ESP8266 AP mode,SSID:ESP8266-WIFI,PWD:0123456789\r\n");
        
        return 0;
}
```



## 4.配置ESP8266建立TCPServer连接



### (1)相关AT命令

```plain
AT+SAVETRANSLINK=0\r\n  关闭上电自动进入透传模式
AT+CIPMUX=1\r\n         支持多路连接
AT+CIPSERVER=1,8888\r\n 创建TCP Server
代码块123
```



### (2)相关代码实现

```c
int esp8266_create_tcp_server(void)
{
        int ret;
        
        //send "AT+SAVETRANSLINK=0\r\n" to close start auto passthrough mode
        esp8266_send_cmd("AT+SAVETRANSLINK=0\r\n");
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 close start auto passthrough mode failed\r\n");
                 return -1;
        }
        
        //allow muti connections
        esp8266_send_cmd("AT+CIPMUX=1\r\n");
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 allow muti connections failed\r\n");
                 return -1;
        }
        
        //build tcp server
        esp8266_send_cmd("AT+CIPSERVER=1,8888\r\n");
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 build tcp server failed\r\n");
                 return -1;
        }
        
        printf("ESP8266 create tcp server success,port:8888\r\n");
        
        return 0;
}
代码块1234567891011121314151617181920212223242526272829303132
```



## 5.ESP8266初始化

```c
void esp8266_init(void)
{
         int ret;
         
         ret = esp8266_reset();
         if(ret < 0){
                        return;
         }        
         
         ret = esp8266_enter_ap_mode();
         if(ret < 0){
                        return;
         }
         
         ret = esp8266_create_tcp_server();
         if(ret < 0){
                 return;
         }
         
         uart_interrupt_init();
}
代码块123456789101112131415161718192021
```



## 6.ESP8266控制小车

```c
void esp8266_car_control(uint8_t *buffer,uint32_t size)
{
        int ret;
        int id;
        int len;
        uint8_t cmd[100] = {0};
        
        //\r\n+IPD,0,1:w
        ret = sscanf((const char *)buffer,"\r\n+IPD,%d,%d:%s\r\n",&id,&len,cmd);
        if(ret != 3){
                return;
        }
        
        switch(cmd[0]){
         case 'w':
                 car_forward(800);
                 printf("forward\r\n");
                 break;
                
         case 's':
                  car_reverse(800);
                  printf("reverse\r\n");
                  break;
        case 'a':
                  car_turn_left(800);
                  printf("turn left\r\n");
                  break;
        
        case 'd':
                  car_turn_right(800);
                  printf("turn right\r\n");
                  break;
        }
        
        HAL_Delay(1000);
        car_stop();
        
        return;
}
```



## 7.定时器优化小车控制



### (1)Stm32CubeMx配置

> 注意中断优先级要高于uart通信中断，方能在定时器中断中发送下车停止信号
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a1bc5dfdd64f4910b6c5fccc20307cea.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d82a9b736e094146bfe542d64842cee6.png)

### (2)定时器相关函数接口

```c
/**
  * @brief  Set the TIM Counter Register value on runtime.
  * @param  __HANDLE__ TIM handle.
  * @param  __COUNTER__ specifies the Counter register new value.
  * @retval None
  */
#define __HAL_TIM_SET_COUNTER(__HANDLE__, __COUNTER__)


/** @brief  Clear the specified TIM interrupt flag.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __FLAG__ specifies the TIM interrupt flag to clear.
  *        This parameter can be one of the following values:
  *            @arg TIM_FLAG_UPDATE: Update interrupt flag
  *            @arg TIM_FLAG_CC1: Capture/Compare 1 interrupt flag
  *            @arg TIM_FLAG_CC2: Capture/Compare 2 interrupt flag
  *            @arg TIM_FLAG_CC3: Capture/Compare 3 interrupt flag
  *            @arg TIM_FLAG_CC4: Capture/Compare 4 interrupt flag
  *            @arg TIM_FLAG_COM:  Commutation interrupt flag
  *            @arg TIM_FLAG_TRIGGER: Trigger interrupt flag
  *            @arg TIM_FLAG_BREAK: Break interrupt flag
  *            @arg TIM_FLAG_CC1OF: Capture/Compare 1 overcapture flag
  *            @arg TIM_FLAG_CC2OF: Capture/Compare 2 overcapture flag
  *            @arg TIM_FLAG_CC3OF: Capture/Compare 3 overcapture flag
  *            @arg TIM_FLAG_CC4OF: Capture/Compare 4 overcapture flag
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  */
#define __HAL_TIM_CLEAR_FLAG(__HANDLE__, __FLAG__)   


/**
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)

/**
  * @brief  Stops the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)

/**
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
```



### (3)代码实现

```c
void esp8266_car_control(uint8_t *buffer,uint32_t size)
{
        int ret;
        int id;
        int len;
        uint8_t cmd[100] = {0};
        
        //\r\n+IPD,0,1:w
        ret = sscanf((const char *)buffer,"\r\n+IPD,%d,%d:%s\r\n",&id,&len,cmd);
        if(ret != 3){
                return;
        }
        
        switch(cmd[0]){
         case 'w':
                 car_forward(800);
                 printf("forward\r\n");
                 break;
                
         case 's':
                  car_reverse(800);
                  printf("reverse\r\n");
                  break;
        case 'a':
                  car_turn_left(800);
                  printf("turn left\r\n");
                  break;
        
        case 'd':
                  car_turn_right(800);
                  printf("turn right\r\n");
                  break;
        }
        
        __HAL_TIM_SET_COUNTER(&htim4,0);
        __HAL_TIM_CLEAR_FLAG(&htim4,TIM_FLAG_UPDATE);
        HAL_TIM_Base_Start_IT(&htim4);
        
        return;
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
        if(htim == &htim4){
           car_stop();
           printf("time over\r\n");
        }
}
```



## 8.完整代码

```c
#include "usart.h"
#include "tim.h"
#include "smartcar.h"
#include <stdio.h>
#include <string.h>

void esp8266_send_cmd(const char *cmd)
{
         int ret;

        printf("Send AT CMD:%s\r\n",cmd);
        
        ret = HAL_UART_Transmit(&huart2,(uint8_t *)cmd,strlen(cmd),1000);
        if(ret != HAL_OK){
                printf("Fail to send AT cmd:%s\r\n",cmd);
                return;
        }
        
        return;
}

int esp8266_recv_ack(void)
{
        int count = 0;
        uint8_t rx_buffer[300];
        uint8_t ack_buffer[1024] = {0};
        
        
        while(count < 3){
                memset(rx_buffer,0,sizeof(rx_buffer));
                HAL_UART_Receive(&huart2,rx_buffer,sizeof(rx_buffer),1000);
                if(strstr((const char *)rx_buffer,"OK")){
                          printf("Recv AT ACK:%s\r\n",rx_buffer);
                          return 0;
                }
                strcat((char *)ack_buffer,(const char *)rx_buffer);
                count ++;
        }
        
        printf("Recv AT ACK:%s\r\n",ack_buffer);
        if(strstr((const char *)ack_buffer,"OK")){
                return 0;
        }
        
        return -1;
}

int esp8266_reset(void)
{
        int ret;
        
        //send "+++" quit passthrough mode
        esp8266_send_cmd("+++");
        HAL_Delay(1000);
        
        //send "AT+RST\r\n" reset esp8266
        esp8266_send_cmd("AT+RST\r\n");
        HAL_Delay(3000);
        
        //send "AT\r\n" test
        esp8266_send_cmd("AT\r\n");
        
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 is not alive\r\n");
                 return -1;
        }
        
        printf("Reset ESP8266 Success\r\n");
        
        return 0;
}

int esp8266_enter_ap_mode(void)
{
        int ret;
        
        //send "AT+CWMODE=2\r\n" to ap mode
        esp8266_send_cmd("AT+CWMODE=2\r\n");
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 enter ap mode failed\r\n");
                 return -1;
        }
        
        //config ap ssid and pwd
        esp8266_send_cmd("AT+CWSAP=\"ESP8266-WIFI\",\"0123456789\",11,4\r\n");
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 config ap ssid and pwd failed\r\n");
                 return -1;
        }
        
        printf("ESP8266 AP mode,SSID:ESP8266-WIFI,PWD:0123456789\r\n");
        
        return 0;
}

int esp8266_create_tcp_server(void)
{
        int ret;
        
        //send "AT+SAVETRANSLINK=0\r\n" to close start auto passthrough mode
        esp8266_send_cmd("AT+SAVETRANSLINK=0\r\n");
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 close start auto passthrough mode failed\r\n");
                 return -1;
        }
        
        //allow muti connections
        esp8266_send_cmd("AT+CIPMUX=1\r\n");
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 allow muti connections failed\r\n");
                 return -1;
        }
        
        //build tcp server
        esp8266_send_cmd("AT+CIPSERVER=1,8888\r\n");
        ret = esp8266_recv_ack();
        if(ret < 0){
                 printf("ESP8266 build tcp server failed\r\n");
                 return -1;
        }
        
        printf("ESP8266 create tcp server success,port:8888\r\n");
        
        return 0;
}

void esp8266_init(void)
{
         int ret;
         
         ret = esp8266_reset();
         if(ret < 0){
                        return;
         }        
         
         ret = esp8266_enter_ap_mode();
         if(ret < 0){
                        return;
         }
         
         ret = esp8266_create_tcp_server();
         if(ret < 0){
                 return;
         }
         
         uart_interrupt_init();
}

void esp8266_car_control(uint8_t *buffer,uint32_t size)
{
        int ret;
        int id;
        int len;
        uint8_t cmd[100] = {0};
        
        //\r\n+IPD,0,1:w
        ret = sscanf((const char *)buffer,"\r\n+IPD,%d,%d:%s\r\n",&id,&len,cmd);
        if(ret != 3){
                return;
        }
        
        switch(cmd[0]){
         case 'w':
                 car_forward(800);
                 printf("forward\r\n");
                 break;
                
         case 's':
                  car_reverse(800);
                  printf("reverse\r\n");
                  break;
        case 'a':
                  car_turn_left(800);
                  printf("turn left\r\n");
                  break;
        
        case 'd':
                  car_turn_right(800);
                  printf("turn right\r\n");
                  break;
        }
        
        __HAL_TIM_SET_COUNTER(&htim4,0);
        __HAL_TIM_CLEAR_FLAG(&htim4,TIM_FLAG_UPDATE);
        HAL_TIM_Base_Start_IT(&htim4);
        
        return;
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
        if(htim == &htim4){
           car_stop();
           printf("time over\r\n");
        }
}

void esp8266_test(void)
{
        esp8266_init();
        
        return;
}

```