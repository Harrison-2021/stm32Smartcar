#  一、数码管工作原理



## 1.介绍

按发光二极管单元连接方式可分为**共阳极数码管**和**共阴极数码管**。

![图片描述](https://img.mukewang.com/wiki/6405be9a096383e006000295.jpg)



## 2.共阳极数码管

<font color="#fd6f01">**共阳数码管是指将所有发光二极管的阳极接到一起形成公共阳极(COM)的数码管**</font>，当某一字段发光二极管的阴极为低电平时，相应字段就点亮，当某一字段的阴极为高电平时，相应字段就不亮。



## 3.共阴极数码管

<font color="#fd6f01">**共阴数码管是指将所有发光二极管的阴极接到一起形成公共阴极(COM)的数码管**</font>，当某一字段发光二极管的阳极为高电平时，相应字段就点亮，当某一字段的阳极为低电平时，相应字段就不亮。



## 4.数码管真值表

<font color=green>**位序是大端**</font>

![图片描述](https://img.mukewang.com/wiki/6405beab0922e2e105780368.jpg)



# 二、原理图阅读及STM32CubeMx配置



## 1.原理图

<font color=green>**使用类似于IIC总线的串行通信（时钟线与数据线），与TM1637模块通信，再将串行通信转为并行通信，同时控制多个数码管**</font>

![图片描述](https://img.mukewang.com/wiki/6405bec509eff1ac12801096.jpg)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/580ce130ae9d4d69828360c2462bd127.png)

## 2.STM32CubeMx配置

将连接芯片的PB5,PB6配置位GPIO模式，自定义拉高拉低，模拟IIC通信信号

![图片描述](https://img.mukewang.com/wiki/6405bedc090676c412800664.jpg)



# 三、**TM1637工作原理介绍**



## 1.介绍

TM1637 是一种带键盘扫描接口的LED（发光二极管显示器）驱动控制专用电路，内部集成有MCU 数字 接口、数据锁存器、LED 高压驱动、键盘扫描等电路。本产品性能优良，质量可靠。主要应用于电磁炉、微波 炉及小家电产品的显示屏驱动。

- 1.8路共阳极
- 通过GRID1-GRD6选择数码管
- 通过SEG1-SEG8控制电平，控制对应数码管显示

![图片描述](https://img.mukewang.com/wiki/6405bef309791c5712800958.jpg)

![图片描述](https://img.mukewang.com/wiki/6405bf020948fc2212800462.jpg)



## 2.数据指令

指令用来设置显示模式和LED 驱动器的状态。<font color=green> **在CLK下降沿后由DIO输入的第一个字节作为一条指令**。**经过译码，取最高B7、B6两位比特位以区别不同的指令。**</font>

如果在**指令或数据传输时发送STOP命令，串行通讯被初始化，并且正在传送的指令或数据无效（之前传送的指令或数据保持有效）**

![图片描述](https://img.mukewang.com/wiki/6405bf1409892b0712800150.jpg)

#### (1)**数据命令设置**

![图片描述](https://img.mukewang.com/wiki/6405bf2409f52b8912800311.jpg)

#### (2)**地址命令设设置**

![图片描述](https://img.mukewang.com/wiki/6405bf35097afce512800358.jpg)

#### (3)显示控制

1.可控制是否显示

2.可通过占空比调整亮度

![图片描述](https://img.mukewang.com/wiki/6405bf44093f994f12800492.jpg)



## 3.通信协议介绍

### 通信原理

微处理器的数据通过两线总线接口和 TM1637 通信，

- **在输入数据时当 CLK 是高电平时，DIO 上的信号必须保持不变**；**只有 CLK 上的时钟信号为低电平时，DIO 上的信号才能改变**。
- **数据输入的开始条件是 CLK 为高电平时，DIO 由高变低**；**结束条件是 CLK 为高时，DIO 由低电平变为高电平**。 

- TM1637 的数据传输带有**应答信号 ACK**，**当传输数据正确时，会在第八个时钟的下降沿，芯片内部会产生一个应答信号 ACK 将 DIO 管脚拉低，在第九个时钟结束之后释放 DIO 口线。**

### 通信协议

- **数据指令:只发一次**，决定以什么方式处理数据：写，固定地址，普通模式

- 地址指令：中间发送数码管的地址指令和数据，**每个数码管都有一个开始信号和结束信号进行分割**
- 显示指令：当发送完所有要操作的数码管数据后，**最后发送显示指令，并发一同显示**

![图片描述](https://img.mukewang.com/wiki/6405bf5709c98f2c12800349.jpg)



# 四、**TM1637**代码实现



## 1.时序模拟

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ffb586c5bca743d49a1ea9973d08b255.png)

#### (1)管脚定义

```apl
#include "gpio.h"
#include <stdio.h>

#define TM1637_CLK_H  HAL_GPIO_WritePin(GPIOB,GPIO_PIN_6,GPIO_PIN_SET)
#define TM1637_CLK_L HAL_GPIO_WritePin(GPIOB,GPIO_PIN_6,GPIO_PIN_RESET)

#define TM1637_DAT_H HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,GPIO_PIN_SET)
#define TM1637_DAT_L HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,GPIO_PIN_RESET)

#define TM1637_DELAY_TIME 1 // 高低电平持续时间ms
```

#### (2)开始信号

```c
void tm1637_start(void)
{
        TM1637_CLK_H;
        TM1637_DAT_H;
        HAL_Delay(TM1637_DELAY_TIME);
        
        TM1637_DAT_L;
        HAL_Delay(TM1637_DELAY_TIME);
        
        return;
}
```

#### (3)停止信号

```c
void tm1637_stop(void)
{
        TM1637_CLK_L;
        TM1637_DAT_L;
        HAL_Delay(TM1637_DELAY_TIME);
    
        TM1637_CLK_H;
        HAL_Delay(TM1637_DELAY_TIME);
        
        TM1637_DAT_H;
        HAL_Delay(TM1637_DELAY_TIME);
        
        return;
}
```

#### (4)应答信号

```c
// ACk信号由从机芯片拉低，只需提供一个CLK周期信号，在第9周期内，会自动应答
void tm1637_read_ack(void) {
         TM1637_CLK_L;
         HAL_Delay(TM1637_DELAY_TIME);
         TM1637_CLK_H;
         HAL_Delay(TM1637_DELAY_TIME); 
         //we don't car ack        
        
         return;
}
```

#### (5)发送一个字节

```c
void tm1637_write_byte(uint8_t data)
{
        int i;
        
        for(i = 0;i < 8;i ++){
            // 低位先传，在CLK信号为低电平时，根据data数据改变DAL电平，
            TM1637_CLK_L;
            HAL_Delay(TM1637_DELAY_TIME);
            // 写数据
            if(data & 1){
                TM1637_DAT_H;
            }else{
                TM1637_DAT_L;
            }
            //维持DAL电平1 ms，可不维持，因在读取期间和下次改变前一直维持电平
            //HAL_Delay(TM1637_DELAY_TIME);
            // 拉高CLK 1ms,让tm1637芯片读取传入的数据
            TM1637_CLK_H;
            HAL_Delay(TM1637_DELAY_TIME);
            // 传入下个低位
            data = data >> 1;
        }
        
        return;
}
```



## 2.数据显示控制

![图片描述](https://img.mukewang.com/wiki/6405bf5709c98f2c12800349.jpg)

#### (1)发送命令

```c
void tm1637_write_cmd(uint8_t cmd)
{
         tm1637_start();
         tm1637_write_byte(cmd);
         tm1637_read_ack();
         tm1637_stop();
        
         return;
}
```

#### (2)给指定地址发送数据

```c
void tm1637_write_data(uint8_t addr,uint8_t data)
{
         tm1637_start();
         tm1637_write_byte(addr);
         tm1637_read_ack();
                
         tm1637_write_byte(data);
         tm1637_read_ack();
        
         tm1637_stop();
        
         return;
}
```

#### (3)显示时间

##### 共阴极数码管真值表

```c
const uint8_t segmentMap[] = {
    0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, // 0-7
    0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71, // 8-9, A-F
    0x00
};
```

##### 代码实现

![图片描述](https://img.mukewang.com/wiki/6405bef309791c5712800958.jpg)

```c
//12:34
void tm1637_display_time(uint8_t hour,uint8_t minute) {	
	tm1637_write_cmd(0x44);
	tm1637_write_data(0xc0,segmentMap[hour/10]);
	tm1637_write_data(0xc1,segmentMap[hour%10] + 0x80);//冒号显示
	
	tm1637_write_data(0xc2,segmentMap[minute/10]);
	tm1637_write_data(0xc3,segmentMap[minute%10]);
	
	tm1637_write_cmd(0x8a);
	
	return;
}
```

### 测试结果

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1555b07ccc7b4baf9d75eab0cd64f09c.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/655557838dfc484ab567ae29ab83a383.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/eff9be07d972461c9c05e2640aaf36ae.png)

## 3.完整代码

```c
#include "gpio.h"
#include <stdio.h>

#define TM1637_CLK_H HAL_GPIO_WritePin(GPIOB,GPIO_PIN_6,GPIO_PIN_SET)
#define TM1637_CLK_L HAL_GPIO_WritePin(GPIOB,GPIO_PIN_6,GPIO_PIN_RESET)

#define TM1637_DAT_H HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,GPIO_PIN_SET)
#define TM1637_DAT_L HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,GPIO_PIN_RESET)

#define TM1637_DELAY_TIME 1

void tm1637_start(void)
{
        TM1637_CLK_H;
        TM1637_DAT_H;
        HAL_Delay(TM1637_DELAY_TIME);
        
        TM1637_DAT_L;
        HAL_Delay(TM1637_DELAY_TIME);
        
        TM1637_CLK_L;
        
        return;
}

void tm1637_stop(void)
{
        TM1637_CLK_L;
        TM1637_DAT_L;
        HAL_Delay(TM1637_DELAY_TIME);
        TM1637_CLK_H;
        HAL_Delay(TM1637_DELAY_TIME);
        
        TM1637_DAT_H;
        HAL_Delay(TM1637_DELAY_TIME);
        
        return;
}

void tm1637_write_byte(uint8_t data)
{
        int i;
        
        for(i = 0;i < 8;i ++){
                 TM1637_CLK_L;
                 HAL_Delay(TM1637_DELAY_TIME);
                 if(data & 1){
                                TM1637_DAT_H;
                 }else{
                          TM1637_DAT_L;
                 }
                 HAL_Delay(TM1637_DELAY_TIME);
                 TM1637_CLK_H;
                 HAL_Delay(TM1637_DELAY_TIME);
                 data = data >> 1;
        }
        
        return;
}

void tm1637_read_ack(void)
{
         TM1637_CLK_L;
         HAL_Delay(TM1637_DELAY_TIME);
         TM1637_CLK_H;
         HAL_Delay(TM1637_DELAY_TIME); 
         //we don't car ack        
         TM1637_CLK_L;
         HAL_Delay(TM1637_DELAY_TIME);
        
         return;
}

void tm1637_write_cmd(uint8_t cmd)
{
         tm1637_start();
         tm1637_write_byte(cmd);
         tm1637_read_ack();
         tm1637_stop();
        
         return;
}

void tm1637_write_data(uint8_t addr,uint8_t data)
{
         tm1637_start();
         tm1637_write_byte(addr);
         tm1637_read_ack();
                
         tm1637_write_byte(data);
         tm1637_read_ack();
        
         tm1637_stop();
        
         return;
}

void tm1637_display_time(uint16_t hour,uint16_t minute)
{        
         const uint8_t segmentMap[] = {
            0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, // 0-7
            0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71, // 8-9, A-F
            0x00
         };
         
         tm1637_write_cmd(0x44);
         tm1637_write_data(0xc0,segmentMap[hour / 10]);
         tm1637_write_data(0xc1,segmentMap[hour % 10] + 0x80);
         tm1637_write_data(0xc2,segmentMap[minute / 10]);
         tm1637_write_data(0xc3,segmentMap[minute % 10]);
         
         tm1637_write_cmd(0x8a);
         
         return;
}

void tm1637_test(void)
{
    int i;        
    while(1){                 
        for(i = 0;i < 60;i ++){
            tm1637_display_time(15,i);
            HAL_Delay(1000);
            printf("time 15:%02d\r\n",i);
        }
    }

    return;
}
```



# 五、RTC时间读取



## 1.硬件原理图阅读及STM32CubeMx配置



### (1)原理图阅读

![图片描述](https://img.mukewang.com/wiki/6405bf73098a70e112800460.jpg)



### (2)STM32CubeMx配置

![图片描述](https://img.mukewang.com/wiki/6405bf9409b9d22412640930.jpg)



<font color="#fd6f01">**选择输入时钟后，定时器会自动分频，1Hz**</font>

![图片描述](https://img.mukewang.com/wiki/6405bf840944834312800660.jpg)

## 2.RTC相关函数介绍



### 1.获取时间及日期

注意:
<font color="#fd6f01">**先调用HAL_RTC_GetTime函数，然后在调用HAL_RTC_GetDate函数，否则获取的时间不正确**</font>

```c
/**
  * @brief  Gets RTC current time.
  * @param  hrtc   pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @param  sTime: Pointer to Time structure
  * @param  Format: Specifies the format of the entered parameters.
  *          This parameter can be one of the following values:
  *            @arg RTC_FORMAT_BIN: Binary data format
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, 
                                  RTC_TimeTypeDef *sTime,
                                  uint32_t Format)
                                  
/**
  * @brief  Gets RTC current date.
  * @param  hrtc   pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @param  sDate: Pointer to Date structure
  * @param  Format: Specifies the format of the entered parameters.
  *          This parameter can be one of the following values:
  *            @arg RTC_FORMAT_BIN:  Binary data format
  *            @arg RTC_FORMAT_BCD:  BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc,
                                  RTC_DateTypeDef *sDate,
                                  uint32_t Format)
                                  
                                  


```



### 2.设置时间及日期

```c
/**
  * @brief  Sets RTC current time.
  * @param  hrtc   pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @param  sTime: Pointer to Time structure
  * @param  Format: Specifies the format of the entered parameters.
  *          This parameter can be one of the following values:
  *            @arg RTC_FORMAT_BIN: Binary data format
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, 
                                  RTC_TimeTypeDef *sTime, 
                                  uint32_t Format)
                                  
/**
  * @brief  Sets RTC current date.
  * @param  hrtc   pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @param  sDate: Pointer to date structure
  * @param  Format: specifies the format of the entered parameters.
  *          This parameter can be one of the following values:
  *            @arg RTC_FORMAT_BIN: Binary data format
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc,
                                  RTC_DateTypeDef *sDate,
                                  uint32_t Format)
```



## 3.代码实现

RTC 不断电情况下，会一直获取

```c
void tm1637_test(void)
{
    int i;
    RTC_TimeTypeDef time;

    while(1){
        for(i = 0;i < 60;i ++){
            HAL_RTC_GetTime(&hrtc,&time,RTC_FORMAT_BIN);
            tm1637_display_time(time.Hours,time.Seconds);
        }
    }

    return;
}
```

### 测试结果

除非断电，否则计时会一直持续下去

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/43068029d32c4098a75aa904735fbffc.png)